// RobotBuilder Version: 5.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "subsystems/DrivetrainModular.h"
#include <frc/smartdashboard/SmartDashboard.h>
#include <frc/Joystick.h>
#include <commands/Drive.h>
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include <iostream>
DrivetrainModular::DrivetrainModular(){

    SetName("Drivetrain Modular");
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SetSubsystem("Drivetrain Modular");
    
DifferentialDrive = new frc::DifferentialDrive(motor_L_main, motor_R_main);
 AddChild("Differential Drive", DifferentialDrive);

//DifferentialDrive->SetSafetyEnabled(true);
//DifferentialDrive->SetExpiration(0.1_s);
//motor_R_main.motor

motor_L_main.RestoreFactoryDefaults();
motor_R_follow.RestoreFactoryDefaults();
motor_L_follow.RestoreFactoryDefaults();
motor_R_main.RestoreFactoryDefaults();
motor_R_main.SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
motor_L_main.SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
motor_R_follow.SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);
motor_L_follow.SetIdleMode(rev::CANSparkMax::IdleMode::kBrake);

motor_R_follow.Follow(motor_R_main);
motor_L_follow.Follow(motor_L_main);
motor_L_main.BurnFlash();
motor_R_follow.BurnFlash();
motor_L_follow.BurnFlash();
motor_R_main.BurnFlash();
 //AddChild("motors_right", &m_motors_right);
  //AddChild("motors_left", &m_motors_left);
/*
 AddChild("Motor_R_1", &m_motor_R_1);
 m_motor_R_1.SetInverted(false);

 AddChild("Motor_R_2", &m_motor_R_2);
 m_motor_R_2.SetInverted(false);
 AddChild("Motor_L_2", &m_motor_L_2);
 m_motor_L_2.SetInverted(false);

 AddChild("Motor_L_1", &m_motor_L_1);
 m_motor_L_1.SetInverted(false);
*/
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
}

void DrivetrainModular::Periodic() {
    // Put code here to be run every loop

}

void DrivetrainModular::SimulationPeriodic() {
     //This method will be called once per scheduler run when in simulation

}

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CMDPIDGETTERS


// Put methods for controlling this subsystem
// here. Call these from Commands.

void DrivetrainModular::StandardDrive(frc::Joystick* driveStick) {
        double maxSpeed = ((driveStick->GetRawAxis(3)*-1)+1)*0.5;
        //double maxSpeed = 1.0;
  //  frc::SmartDashboard::PutNumber("MaxSpeed", (((driveStick->GetRawAxis(3)*-1)+1)*0.5));
    DifferentialDrive->SetMaxOutput(maxSpeed/*((driveStick->GetRawAxis(3)*-1)+1)*0.5*/);
    if (driveStick->GetMagnitude() > .1){
    DifferentialDrive->ArcadeDrive(driveStick->GetX()*maxSpeed, driveStick->GetY()*maxSpeed, false);
    }
    //std::cout << "vrroom vroom im drivin my mahms cah: " <<  << "\n";
    frc::SmartDashboard::PutNumber("drivetrain right motors", motor_R_main.Get());
    frc::SmartDashboard::PutNumber("drivetrainsm left motors ", motor_L_main.Get());
}
